
(defparameter *words* (make-hash-table :size 10000))

(defconstant maxword 100)

;;added read-stream so that the code operates on a stream
;;makes the code more flexible since streams are more flexible than files or strings
;;removed (if (progn statements as-per lisp critic
;;alterations to pos now happen in the variable update portion of do-body as per lisp critic
(defun read-stream (stream fn)
  (let ((buffer (make-string maxword))
        (see (make-see)))
    (do ((c (read-char stream nil :eof) 
            (read-char stream nil :eof))
         (pos 0 (update-buffer-return-pos buffer pos c fn)))
        ((eql c :eof)))))

(defun update-buffer-return-pos (buffer pos c fn)
  (cond ((or (alpha-char-p c) (char= c #\')) 
         (setf (aref buffer pos) c)
         (1+ pos))
        (t (unless (zerop pos)
             (funcall fn (intern (string-downcase
                                  (subseq buffer 0 pos)))))
           (let ((p (punc c)))
             (when p (funcall fn p))) 0)))
    
    
    
;;changed read-text to be a driver function for read-stream for the reasons
;;mentioned before read-stream
(defun read-text (pathname)
  (with-open-file (stream pathname :direction :input)
    (let ((see (make-see)))
      (read-stream stream see)))
  (hash-table-count *words*)) 

(defun punc (c)
  (case c
    (#\. '|.|) (#\, '|,|) (#\; '|;|) 
    (#\! '|!|) (#\? '|?|) ))

;;changed to a function that generates and returns a function
;;instead of the previous function that assigned the function to a variable
;;this allows us to reload the whole form
(defun make-see ()
  (let ((prev `|.|))
    (lambda (symb)
      (let ((pair (assoc symb (gethash prev *words*))))
        (if (null pair)
            (push (cons symb 1) (gethash prev *words*))
          (incf (cdr pair))))
      (setf prev symb))))

;;altered to be iterative as suggested
;;the code is more readable this way, in my opinion,
;;and allows us to drop an argument and variable
(defun generate-text (n) 
  (do ((n1 n (1- n1))
       (next (random-next '|.|) (random-next next)))
      ((zerop n1) (terpri))
    (format t "~A " next)))

(defun random-next (prev)
  (let* ((choices (gethash prev *words*))
         (i (random (reduce #'+ choices 
                            :key #'cdr))))
    (dolist (pair choices)
      (if (minusp (decf i (cdr pair)))
          (return (car pair))))))

;;added henley-p to return true iff str could have been generated by generate-text
(defun henley-p (str)
  (with-input-from-string (in str)
    (let ((prev `|.|))
      (read-stream in (lambda (x) 
                        (unless (assoc x (gethash prev *words*))
                          (return-from henley-p))
                        (setf prev x))))) t)